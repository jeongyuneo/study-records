# 04. 역할, 책임, 협력

- 책임은 객체에 의해 정의되는 응집도있는 행위의 집합으로, 객체의 책임은 **‘객체가 무엇을 알고 있는가’** 와 **‘무엇을 할 수 있는가’** 로 구성된다.
    - 하는 것
        - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
        - 다른 객체의 행동을 시작시키는 것
        - 다른 객체의 활동을 제어하고 조절하는 것
    - 아는 것
        - 개인적인 정보에 관해 아는 것
        - 관련된 객체에 관해 아는 것
        - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해줄 수 있는 서비스(하는 것의 측면)의 목록이다.
- 책임은 객체의 **공용 인터페이스(public interface)** 를 구성한다. → 캡슐화로 이어짐
- 두 객체 간의 협력은 메시지를 통해 이뤄진다.
    - 책임: 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지 나열
    - 메시지: 협력에 참여하는 두 객체 사이의 관계를 강조
- 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다.
- 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다. 또한 다양한 객체들이 협력에 참여할 수 있기 때문에 협력이 좀 더 유연해지며 다양한 객체들이 동일한 협력에 참여할 수 있기 때문에 재사용성이 높아진다.
- 역할은 객체지향 설계의 **단순성(simplicity)**, **유연성(flexibility)**, **재사용성(reusability)** 을 뒷받침하는 핵심 개념이다.
- 역할을 이용하면 협력을 추상화함으로써 단순화할 수 있다.
    - 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다.
    - 협력의 추상화는 설계자가 다뤄야하는 협력의 개수를 줄이는 동시에 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화한다.
- 역할은 다른 객체에 의해 대체 가능함을 의미한다.
- 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.
    - 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다.
    - 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. → 객체의 타입과 역할 사이에 일반화/특수화 관계 성립
- 객체지향에 대한 선입견
    1. 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다.

       : 객체가 상태의 일부로 데이터를 포함하지만 데이터는 단지 객체가 행위를 수행하는데 필요한 재료일 뿐이다.

    2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다.

       : 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체이며, 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘이다.

- 객체지향의 핵심은 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지 결정하는 것이다.
- 올바른 객체를 설계하기 위해는 협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다.
- 객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것이다.
- 객체지향 설계기법
    1. 책임-주도 설계(Responsibility-Driven Design)

       : **협력에 필요한 책임들을 식별**하고 **적합한 객체에게 책임을 할당**하는 방식으로 애플리케이션을 설계하는 방법

        - 책임-주도 설계는 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다.

          ⇒ 결과적으로 시스템은 스스로 자신을 책임질 수 있을 정도로 충분히 자율적인 동시에 다른 객체와 우호적으로 협력할 수 있을 정도로 충분히 협조적인 객체들로 이뤄진 생태계를 구성하게 된다.

        - 객체지향 시스템 설계 절차
            1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
            2. 시스템 책임을 더 작은 책임으로 분할한다.
            3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.

               (<u>만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.</u>)

            4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
            5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.
    2. 디자인 패턴(Design Pattern)

       : 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의됨

        > 패턴(pattern): 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음(모범이 되는 설계)

        - **책임-주도 설계**는 객체의 역할, 책임, 협력을 고안하기 위한 **방법과 절차**를 제시한 반면 **디자인 패턴**은 책임-주도 설계의 **결과**를 표현한다.
    3. 테스트-주도 개발(Test-Driven Development)

       : 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해나가는 설계를 위한 기법

        - 구체적인 코드를 작성해나가면서 역할, 책임, 협력을 식별하고 식별된 역할, 책임, 협력이 적합한지를 피드백을 받는 것이 목적이다.
        - 테스트-주도 개발의 기본 흐름

          : 실패하는 테스트 작성 → 테스트를 통과하는 가장 간단한 코드 작성(중복 허용) → 리팩토링(refactoring)을 통해 중복을 제거

        - 테스트-주도 개발은 **응집도가 높고 결합도가 낮은** 클래스로 구성된 시스템을 개발할 수 있게 하는 최상의 프랙티스다.
        - 테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 개체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.
        - 테스트에 필요한 간접 입력 값을 제공하기 위해 스텁(stub)을 추가하거나 간접 출력 값을 검증하기 위해 목 객체(mock object)를 사용하는 것은 객체와 협력해야 하는 협력자에 관해 고민한 결과를 코드로 표현한 것이다.
    
            > **스텁(stub)**
            > - 인스턴스화하여 구현한 가짜 객체(기능 구현X)를 이용해 실제로 동작하는 것처럼 보이게 만드는 객체
            > - 테스트에서 호출될 요청에 대해 미리 준비해둔 답변을 응답
            > 
            > **목(mock)**
            > - 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍된 객체
            > - 행위 검증을 진행